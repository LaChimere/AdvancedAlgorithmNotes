贪心是一种在每次决策时采取当前意义下最优策略的算法, 因此是用贪心法要求 **问题的整体最优性可以由局部最优性导出**. 贪心算法的正确性需要证明, 常见的证明方法有:

1. 微扰(邻项交换)
   
   证明在任意局面下, 任何对局部最优策略的微小改变都会造成整体结果变差. 常用于以排序为贪心策略的证明.

2. 范围缩放
   
   证明任何对局部最优策略作用范围的扩展都不会造成整体结果变差.

3. 决策包容性
   
   证明在任意局面下, 做出局部最优策略以后, 在问题状态空间中的可达集合包含了作出其他任何决策后可达的集合, 即这个局部最优策略提供的可能性包含其他所有策略提供的可能性.

4. 反证法

5. 数学归纳法


# 例题

* 例1. [防晒](https://www.acwing.com/problem/content/112/)

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAXSIZE = 2510;
struct cow {
    int minSPF, maxSPF;
    bool operator < (const cow& b) const
    {
        return this->minSPF < b.minSPF;
    }
} cows[MAXSIZE];
map<int, int, greater<>> creams;
int C, L;

int main()
{
    cin >> C >> L;
    for (int i = 0; i < C; i++)
        cin >> cows[i].minSPF >> cows[i].maxSPF;
    for (int i = 0; i < L; i++)
    {
        int spf, cover;
        cin >> spf >> cover;
        creams[spf] += cover;
    }
    sort(cows, cows + C);

    int cnt = 0;
    for (int i = C - 1; i >= 0; i--)
    {
        auto it = creams.lower_bound(cows[i].maxSPF);
        if (it == creams.end())
            break;
        if (it->first >= cows[i].minSPF)
        {
            cnt++;
            if (--it->second == 0)
                creams.erase(it);
        }
    }
    cout << cnt;

    return 0;
}
```